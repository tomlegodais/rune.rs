use num_bigint::BigUint;
use num_traits::Num;

pub const MODULUS: &str = "129792996338865251963126643988596996720072633146969539440281778959016153061754455583589842714770006380363039568659750973278228571148845466851600564516017951101034459842947540501966343376879636558259828889909314399933785798161654538562770788737383888023632830865777674023521713178116488997886496990330549017579";
pub const EXPONENT: &str = "97475952313999860176284088232216237874258127940868421833639453722077849726818324753478317112139172437479415361244248030178084624614721837022886738558583493471717251016119619844909265833664204060971622394633700471408984808264493859542588005389087653136956152661087470516085942172902790946240809241091755713273";

pub fn rsa_decrypt(cipher_bytes: &[u8], modulus: &str, exponent: &str) -> anyhow::Result<Vec<u8>> {
    let cipher = BigUint::from_bytes_be(cipher_bytes);
    let n = BigUint::from_str_radix(modulus, 10)?;
    let d = BigUint::from_str_radix(exponent, 10)?;
    let plain = cipher.modpow(&d, &n);

    Ok(plain.to_bytes_be())
}
